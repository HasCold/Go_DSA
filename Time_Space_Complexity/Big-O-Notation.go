// Here's a summarized list of common time complexities with explanations for each:

// ### Time Complexities

// 1. **O(1)** (Constant Time)
//    - The algorithm's runtime does not change with the input size.
//    - Example: Accessing an element in an array by index.

// 2. **O(log n)** (Logarithmic Time)
//    - The algorithm reduces the problem size by a fraction (usually by half) at each step.
//    - Example: Binary search in a sorted array.

// 3. **O(n)** (Linear Time)
//    - The algorithm's runtime increases linearly with the input size.
//    - Example: Finding the maximum element in an array with one loop.

// 4. **O(n log n)** (Linearithmic Time)
//    - Common in algorithms that divide the problem in a logarithmic manner and then perform a linear operation on the results.
//    - Example: Merge sort or quicksort.

// 5. **O(n²)** (Quadratic Time)
//    - The algorithm contains two nested loops over the input.
//    - Example: Bubble sort or checking for duplicates in an array with two loops.

// 6. **O(n³)** (Cubic Time)
//    - The algorithm contains three nested loops over the input.
//    - Example: Multiplying two matrices.

// 7. **O(2ⁿ)** (Exponential Time)
//    - The algorithm's runtime doubles with each additional element in the input.
//    - Example: Solving the Fibonacci sequence using naive recursion.

// 8. **O(n!)** (Factorial Time)
//    - The algorithm's runtime grows factorially with the input size, usually due to generating all permutations.
//    - Example: The traveling salesman problem using brute-force search.

// ### Memorization Tips
// - **Understand the Patterns**: Notice that as you go from O(1) to O(n!), the complexity increases dramatically.
// - **Use Examples**: Relate each time complexity to a specific algorithm or problem to make it easier to remember.
// - **Visual Aids**: Create diagrams or charts showing how different algorithms scale with input size.
// - **Practice Problems**: Solve problems with different complexities to reinforce your understanding.

// Memorizing these complexities will help you analyze algorithms more effectively!

package main

func main() {

}
